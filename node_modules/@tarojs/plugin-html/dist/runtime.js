import { isString, isFunction, mergeReconciler, warn } from '@tarojs/shared';

function genAttrMapFnFromDir(dir) {
  const fn = function (key, value) {
    key = key.toLowerCase();

    if (key in dir) {
      const res = dir[key];

      if (isString(res)) {
        key = res;
      } else {
        key = res[0];
        value = res[1][value] || value;
      }
    }

    return [key, value];
  };

  return fn;
}

const inlineElements = new Set(["i", "abbr", "select", "acronym", "small", "bdi", "kbd", "strong", "big", "map", "sub", "sup", "br", "mark", "meter", "template", "cite", "object", "time", "code", "output", "u", "data", "picture", "tt", "datalist", "var", "dfn", "del", "q", "em", "s", "embed", "samp", "b"]);
const blockElements = new Set(["body", "svg", "address", "fieldset", "li", "span", "article", "figcaption", "main", "aside", "figure", "nav", "blockquote", "footer", "ol", "details", "p", "dialog", "h1", "h2", "h3", "h4", "h5", "h6", "pre", "dd", "header", "section", "div", "hgroup", "table", "dl", "hr", "ul", "dt", "view", "view-block"]);
const specialElements = new Map([['slot', 'slot'], ['form', 'form'], ['iframe', 'web-view'], ['img', 'image'], ['audio', 'audio'], ['video', 'video'], ['canvas', 'canvas'], ['a', {
  mapName(props) {
    return !props.href || /^javascript/.test(props.href) ? 'view' : 'navigator';
  },

  mapNameCondition: ['href'],
  mapAttr: genAttrMapFnFromDir({
    href: 'url',
    target: ['openType', {
      _blank: 'navigate',
      _self: 'redirect'
    }]
  })
}], ['input', {
  mapName(props) {
    if (props.type === 'checkbox') {
      return 'checkbox';
    } else if (props.type === 'radio') {
      return 'radio';
    }

    return 'input';
  },

  mapNameCondition: ['type'],

  mapAttr(key, value, props) {
    key = key.toLowerCase();

    if (key === 'autofocus') {
      key = 'focus';
    } else if (key === 'readonly') {
      if (props.disabled === true) {
        value = true;
      }

      key = 'disabled';
    } else if (key === 'type') {
      if (value === 'password') {
        key = 'password';
        value = true;
      } else if (value === 'tel') {
        value = 'number';
      }
    }

    return [key, value];
  }

}], ['label', {
  mapName: 'label',
  mapAttr: genAttrMapFnFromDir({
    htmlfor: 'for'
  })
}], ['textarea', {
  mapName: 'textarea',
  mapAttr: genAttrMapFnFromDir({
    autofocus: 'focus',
    readonly: 'disabled'
  })
}], ['progress', {
  mapName: 'progress',

  mapAttr(key, value, props) {
    if (key === 'value') {
      const max = props.max || 1;
      key = 'percent';
      value = Math.round(value / max * 100);
    }

    return [key, value];
  }

}], ['button', {
  mapName: 'button',

  mapAttr(key, value) {
    if (key === 'type' && (value === 'submit' || value === 'reset')) {
      key = 'formType';
    }

    return [key, value];
  }

}]]);

function isHtmlTags(nodeName) {
  if (inlineElements.has(nodeName) || blockElements.has(nodeName) || specialElements.has(nodeName)) {
    return true;
  }

  return false;
}

function getMappedType(nodeName, rawProps) {
  if (inlineElements.has(nodeName)) {
    return 'text';
  } else if (specialElements.has(nodeName)) {
    const mapping = specialElements.get(nodeName);

    if (isString(mapping)) {
      return mapping;
    }

    const {
      mapName
    } = mapping;
    return isFunction(mapName) ? mapName(rawProps) : mapName;
  } else {
    return 'view';
  }
}

function getAttrMapFn(nodeName) {
  const mapping = specialElements.get(nodeName);

  if (!isString(mapping)) {
    return mapping === null || mapping === void 0 ? void 0 : mapping.mapAttr;
  }
}

function getMapNameByCondition(nodeName, attr, props) {
  const mapping = specialElements.get(nodeName);
  if (!mapping || isString(mapping)) return;
  const {
    mapName,
    mapNameCondition
  } = mapping;
  if (!mapNameCondition) return;

  if (mapNameCondition.indexOf(attr) > -1 && !isString(mapName)) {
    return mapName(props);
  }
}

function mapNameByContion(nodeName, key, element) {
  const mapName = getMapNameByCondition(nodeName, key, element.props);

  if (mapName) {
    element.enqueueUpdate({
      path: `${element._path}.${"nn"
      /* NodeName */
      }`,
      value: mapName
    });
  }
}

function ensureHtmlClass(tagName, className = '') {
  const classList = className.split(' ');
  const htmlClass = `h5-${tagName}`;

  if (classList.indexOf(htmlClass) === -1) {
    classList.push(htmlClass);
  }

  return classList.join(' ');
}

function ensureRect(props, style = '') {
  let cssText = style;
  const {
    width,
    height
  } = props;

  if (width) {
    cssText = `width: ${width};${cssText}`;
  }

  if (height) {
    cssText = `height: ${height};${cssText}`;
  }

  return cssText;
}

function defineMappedProp(obj, propName, mapName) {
  Object.defineProperty(obj, propName, {
    enumerable: true,
    configurable: true,

    get() {
      return obj[mapName];
    },

    set(val) {
      obj[mapName] = val;
    }

  });
}

const hostConfig = {
  modifyHydrateData(data) {
    const nodeName = data["nn"
    /* NodeName */
    ];
    if (!isHtmlTags(nodeName)) return;
    process.env.NODE_ENV !== 'production' && warn(data["nn"
    /* NodeName */
    ] === 'select', '请使用 Picker 组件代替 <select>'); // map nodeName

    data["nn"
    /* NodeName */
    ] = getMappedType(nodeName, data); // map attr Key/Value

    const attrMapFn = getAttrMapFn(nodeName);

    if (attrMapFn) {
      for (const key in data) {
        const value = data[key];
        const [mapKey, mapValue] = attrMapFn(key, value, data);

        if (key !== mapKey) {
          delete data[key];
          data[mapKey] = mapValue;
        } else if (value !== mapValue) {
          data[key] = mapValue;
        }
      }
    }

    if (nodeName === 'br') {
      data["cn"
      /* Childnodes */
      ] = [{
        ["nn"
        /* NodeName */
        ]: '#text',
        v: '\n'
      }];
    }

    data["cl"
    /* Class */
    ] = ensureHtmlClass(nodeName, data["cl"
    /* Class */
    ]);
    data["st"
    /* Style */
    ] = ensureRect(data, data["st"
    /* Style */
    ]);
  },

  modifySetAttrPayload(element, key, payload) {
    const {
      nodeName,
      _path,
      props
    } = element;
    if (!isHtmlTags(nodeName)) return; // map nodeName

    mapNameByContion(nodeName, key, element); // map attr Key/Value

    const attrMapFn = getAttrMapFn(nodeName);

    if (attrMapFn) {
      const value = payload.value;
      const [mapKey, mapValue] = attrMapFn(key, value, props);
      payload.path = `${_path}.${mapKey}`;
      payload.value = mapValue;
    }

    if (key === "cl"
    /* Class */
    ) {
      payload.value = ensureHtmlClass(nodeName, payload.value);
    } else if (key === "st"
    /* Style */
    || key === 'width' || key === 'height') {
      payload.path = `${_path}.${"st"
      /* Style */
      }`;
      payload.value = ensureRect(props, element.style.cssText);
    }
  },

  modifyRmAttrPayload(element, key, payload) {
    const {
      nodeName,
      _path,
      props
    } = element;
    if (!isHtmlTags(nodeName)) return; // map nodeName

    mapNameByContion(nodeName, key, element); // map attr Key/Value

    const attrMapFn = getAttrMapFn(nodeName);

    if (attrMapFn) {
      const value = payload[key];
      const [mapKey] = attrMapFn(key, value, props);
      payload.path = `${_path}.${mapKey}`;
    }

    if (key === "cl"
    /* Class */
    ) {
      payload.value = ensureHtmlClass(nodeName, payload.value);
    } else if (key === "st"
    /* Style */
    || key === 'width' || key === 'height') {
      payload.path = `${_path}.${"st"
      /* Style */
      }`;
      payload.value = ensureRect(props, element.style.cssText);
    }
  },

  onAddEvent(type, _handler, _options, node) {
    if (!isHtmlTags(node.nodeName)) return;

    if (type === 'click') {
      defineMappedProp(node.__handlers, type, 'tap');
    } else if (node.nodeName === 'input') {
      if (type === 'change') {
        if (node.props.type === 'checkbox' || node.props.type === 'radio') {
          defineMappedProp(node.__handlers, type, 'tap');
        } else {
          defineMappedProp(node.__handlers, type, 'input');
        }
      } else if (type === 'keypress') {
        defineMappedProp(node.__handlers, type, 'confirm');
      }
    }
  },

  modifyTaroEvent(event, element) {
    const {
      nodeName,
      props
    } = element;

    if (nodeName === 'input' && event.type === 'tap') {
      if (props.type === 'checkbox') {
        props.checked = !props.checked;
      } else if (props.type === 'radio' && !props.checked) {
        props.checked = true;
      }

      if (event.mpEvent) {
        const {
          currentTarget,
          target
        } = event.mpEvent;
        currentTarget.checked = props.checked;

        if (target.id === currentTarget.id) {
          target.checked = props.checked;
        }
      }
    }
  }

};
mergeReconciler(hostConfig); //# sourceMappingURL=runtime.js.map