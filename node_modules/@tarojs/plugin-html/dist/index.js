'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var shared = require('@tarojs/shared');
var path = require('path');
var parser = require('@babel/parser');
var traverse = _interopDefault(require('@babel/traverse'));
var t = require('@babel/types');
var generator = _interopDefault(require('@babel/generator'));

var index = (ctx, options) => {
    const inlineElements = ['i', 'abbr', 'select', 'acronym', 'small', 'bdi', 'kbd', 'strong', 'big', 'map', 'sub', 'sup', 'br', 'mark', 'meter', 'template', 'cite', 'object', 'time', 'code', 'output', 'u', 'data', 'picture', 'tt', 'datalist', 'var', 'dfn', 'del', 'q', 'em', 's', 'embed', 'samp', 'b'];
    const blockElements = ['body', 'svg', 'address', 'fieldset', 'li', 'span', 'article', 'figcaption', 'main', 'aside', 'figure', 'nav', 'blockquote', 'footer', 'ol', 'details', 'p', 'dialog', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'pre', 'dd', 'header', 'section', 'div', 'hgroup', 'table', 'dl', 'hr', 'ul', 'dt', 'view', 'view-block'];
    const specialElements = ['slot', 'form', 'iframe', 'img', 'audio', 'video', 'canvas', 'a', 'input', 'label', 'textarea', 'progress', 'button'];
    patchMappingElements(ctx, options, inlineElements, blockElements);
    // 默认允许使用 getBoundingClientRect 等 API
    ctx.modifyWebpackChain(({ chain }) => {
        chain
            .plugin('definePlugin')
            .tap(args => {
            var _a;
            args[0].ENABLE_SIZE_APIS = (_a = options.enableSizeAPIs) !== null && _a !== void 0 ? _a : true;
            return args;
        });
    });
    ctx.registerMethod({
        name: 'onSetupClose',
        fn(platform) {
            injectRuntimePath(platform);
            modifyPostcssConfigs(platform.config, options);
        }
    });
    // React 收集使用到的小程序组件
    ctx.onParseCreateElement(({ nodeName, componentConfig }) => {
        if (!(inlineElements.includes(nodeName) ||
            blockElements.includes(nodeName) ||
            specialElements.includes(nodeName)))
            return;
        const simple = ['audio', 'button', 'canvas', 'form', 'label', 'progress', 'textarea', 'video'];
        const special = {
            a: ['navigator'],
            iframe: ['web-view'],
            img: ['image'],
            input: ['input', 'checkbox', 'radio']
        };
        const includes = componentConfig.includes;
        if (simple.includes(nodeName) && !includes.has(nodeName)) {
            includes.add(nodeName);
        }
        else if (nodeName in special) {
            const maps = special[nodeName];
            maps.forEach(item => {
                !includes.has(item) && includes.add(item);
            });
        }
    });
    // 如果组件使用渲染函数而不是模板，我们分析不了使用到的内置组件，所以只能默认加上所有 HTML 对应的小程序组件模板
    ctx.modifyComponentConfig(({ componentConfig, config }) => {
        if (config.framework === 'vue' || config.framework === 'vue3') {
            ['audio', 'button', 'canvas', 'form', 'label', 'progress', 'textarea', 'video', 'navigator', 'web-view', 'image', 'input', 'checkbox', 'radio'].forEach(item => {
                componentConfig.includes.add(item);
            });
        }
    });
    // 修改 H5 postcss options
    ctx.modifyRunnerOpts(({ opts }) => {
        modifyPostcssConfigs(opts, options, true);
    });
};
function injectRuntimePath(platform) {
    const injectedPath = '@tarojs/plugin-html/dist/runtime';
    if (shared.isArray(platform.runtimePath)) {
        platform.runtimePath.push(injectedPath);
    }
    else if (shared.isString(platform.runtimePath)) {
        platform.runtimePath = [platform.runtimePath, injectedPath];
    }
}
function modifyPostcssConfigs(config, options, isH5) {
    config.postcss || (config.postcss = {});
    const postcssConfig = config.postcss;
    if (!isH5) {
        postcssConfig.htmltransform = {
            enable: true
        };
    }
    if (options.pxtransformBlackList) {
        postcssConfig.pxtransform || (postcssConfig.pxtransform = {
            enable: true
        });
        const pxtransformConfig = postcssConfig.pxtransform;
        if (pxtransformConfig.enable) {
            pxtransformConfig.config || (pxtransformConfig.config = {});
            const config = pxtransformConfig.config;
            config.selectorBlackList || (config.selectorBlackList = []);
            config.selectorBlackList = config.selectorBlackList.concat(options.pxtransformBlackList);
        }
    }
}
function patchMappingElements(ctx, options, inlineElements, blockElements) {
    var _a;
    const helper = ctx.helper;
    const filePath = path.resolve(__dirname, './runtime.js');
    const content = helper.fs.readFileSync(filePath).toString();
    const ast = parser.parse(content, { sourceType: 'unambiguous' });
    (_a = options.modifyElements) === null || _a === void 0 ? void 0 : _a.call(options, inlineElements, blockElements);
    traverse(ast, {
        VariableDeclarator(path) {
            const node = path.node;
            const varid = node.id;
            if (varid.type === 'Identifier') {
                if (varid.name === 'inlineElements') {
                    node.init = getNewExpression(inlineElements);
                }
                if (varid.name === 'blockElements') {
                    node.init = getNewExpression(blockElements);
                }
            }
        }
    });
    const str = generator(ast).code;
    helper.fs.writeFileSync(filePath, str);
}
function getNewExpression(elements) {
    return t.newExpression(t.identifier('Set'), [t.arrayExpression(elements.map(el => t.stringLiteral(el)))]);
}

exports.default = index;
//# sourceMappingURL=index.js.map
